#define WINVER 0x0502
#include <iostream>
#include <windows.h>
#include <stdio.h>
#include <tchar.h>

using namespace std;

#define INFO_BUFFER_SIZE 32767
#define BUFSIZE MAX_PATH
#define MAX_KEY_LENGTH 255
#define FILESYSNAMEBUFSIZE MAX_PATH

double PCFreq = 0.0;
__int64 CounterStart = 0;

void StartCounter()
{
    LARGE_INTEGER freq;
    if (!QueryPerformanceFrequency(&freq))
        std::cout << "Function QueryPerformanceFrequency() failed!\n";

    PCFreq = double(freq.QuadPart);

    printf("\n2.1.  CPU frequency: %u  Hz\n", freq);
    QueryPerformanceCounter(&freq);
    CounterStart = freq.QuadPart;
}

//Подсчет кол-ва тактов ЦП, которе занимает исполнение предыдущего пункта
double GetCounter()
{
    LARGE_INTEGER li;
    QueryPerformanceCounter(&li);
    return double ((li.QuadPart - CounterStart)* 1000000) / PCFreq;
}

int main()
{
// Пункт 1.1
    OSVERSIONINFO lpVersionInformation = {0};
    lpVersionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&lpVersionInformation);
    unsigned verh=lpVersionInformation.dwMajorVersion;
    unsigned niz=lpVersionInformation.dwMinorVersion;
    std::cout<<"1.1. \nWindows version : "<<verh<<"."<<niz<<"\n";
// Пунтк 1.2
    TCHAR  lpBuffer[INFO_BUFFER_SIZE];
    DWORD  nSize = INFO_BUFFER_SIZE;
    GetSystemDirectory(lpBuffer, nSize);
    std::cout<<"\n1.2.  \nSystem directory : "<<lpBuffer<<"\n";
// Пункт 1.3
    GetComputerName(lpBuffer,&nSize);
    std::cout<<"\n1.3.  \nComputer Name : "<<lpBuffer<<"\n";
    nSize = INFO_BUFFER_SIZE;
    GetUserName(lpBuffer,&nSize);
    std::cout<<"User Name : "<<lpBuffer<<"\n";
// Пункт 1.4
    DWORD  CharCount = MAX_PATH;
    CHAR Names[MAX_PATH];
    CHAR VolumeName[MAX_PATH];

    HANDLE hFindVol = FindFirstVolume(VolumeName, BUFSIZE);
    std::cout<<"\nFirst Volume : "<<VolumeName;
	__int64 total, available, free;
    GetVolumePathNamesForVolumeName(VolumeName, Names, CharCount, &CharCount);
    std::cout<<"\nFirst path: "<<Names;
    GetDiskFreeSpaceEx((LPCSTR)Names, (PULARGE_INTEGER)&available, (PULARGE_INTEGER)&total, (PULARGE_INTEGER)&free);
	std::cout << "\nTotal size (byte): " << total << "  Free space (byte): " << available<<"\n";
	while (1) {
		BOOL hNextVol = FindNextVolume(hFindVol, VolumeName, BUFSIZE);
		if (GetLastError() != 18)
		{
			std::cout<<"\nNext name: "<<VolumeName;
			GetVolumePathNamesForVolumeName(VolumeName, Names, CharCount, &CharCount);
            std::cout<<"\nFirst path: "<<Names;
			GetDiskFreeSpaceEx((LPCSTR)Names, (PULARGE_INTEGER)&available, (PULARGE_INTEGER)&total, (PULARGE_INTEGER)&free);
			std::cout << "\nTotal size (byte): " << total << "  Free space (byte): " << available<<"\n";
		}
		else {
			BOOL hCloseVol = FindVolumeClose(hFindVol);
			if (hCloseVol != 0)
			{
				break;
			}
		}
	}
// Пункт 1.5
    DWORD dwSize;
    TCHAR szName[MAX_KEY_LENGTH];
    HKEY hKey;
    DWORD dwIndex = 0;
    DWORD retCode;
    DWORD BufferSize = 8192;
    PPERF_DATA_BLOCK PerfData = (PPERF_DATA_BLOCK)malloc(BufferSize);
    DWORD cbData = BufferSize;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Run",
        0, KEY_ALL_ACCESS, &hKey) == !ERROR_SUCCESS)
    {
        printf("Function RegOpenKeyEx() failed!\n");
    }
    else printf("\n1.5.  Startup commands:\n");

    while (1) {
        dwSize = sizeof(szName);
        retCode = RegEnumValue(hKey, dwIndex, szName, &dwSize, NULL, NULL, NULL, NULL);
        if (retCode == ERROR_SUCCESS)
        {
            RegQueryValueEx(hKey, szName, NULL, NULL, (LPBYTE)PerfData, &cbData);
            printf("      %d: %s:  %s\n", dwIndex + 1, szName, PerfData);
            dwIndex++;
        }
        else break;
    }

    RegCloseKey(hKey);

    StartCounter();
    std::cout << "\n2.2.  CPU clock count : " << GetCounter()  << "  us \n";
    return 0;
}
